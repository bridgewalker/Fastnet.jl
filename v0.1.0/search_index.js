var documenterSearchIndex = {"docs":
[{"location":"customization.html#Customization","page":"Customization","title":"Customization","text":"","category":"section"},{"location":"customization.html","page":"Customization","title":"Customization","text":"FastNet is designed to run the most common types of discrete-event network simulations efficiently.  If what you need to do is very different from these typical use cases you will probably need a different tool. However, between these extremes there is a grey area where you may be able to achieve your goals by  customizing Fastnet. ","category":"page"},{"location":"customization.html#Constom-Output-Functions","page":"Customization","title":"Constom Output Functions","text":"","category":"section"},{"location":"customization.html","page":"Customization","title":"Customization","text":"If you all you need is a different output, you can pass your own reporting function to FastSim. For reference, the default reporting function is called showresults and can be found in the simulation.jl source file.  The reporting function is a function of the form ","category":"page"},{"location":"customization.html","page":"Customization","title":"Customization","text":"MyReportingFunction(sim::FastSim,head::Bool)","category":"page"},{"location":"customization.html","page":"Customization","title":"Customization","text":"The first argument that is passed is a reference to the sim that should be reported on. The second argument is a bool that tells the function whether a header needs to be printed. For example the default reporting function prints first the column heads of the output table and then the network state if true is passed. It prints only the network state if false is passed.  ","category":"page"},{"location":"customization.html","page":"Customization","title":"Customization","text":"Once called your custom reporting function should handle all the neccessary printing, writing to disk, etc.   Also your reporting function should push the node and link counts to the sim.results dataframe, if you want the  results to be stored there. You can do this by including ","category":"page"},{"location":"customization.html","page":"Customization","title":"Customization","text":"    net=sim.net\r\n    nodes=nodecounts_f(net)\r\n    links=linkcounts_f(net)\r\n    push!(sim.results,[sim.t,nodes...,links...])","category":"page"},{"location":"customization.html","page":"Customization","title":"Customization","text":"as the first lines of your reporting function.","category":"page"},{"location":"customization.html","page":"Customization","title":"Customization","text":"Some useful information can be read from the first argument sim:","category":"page"},{"location":"customization.html","page":"Customization","title":"Customization","text":"sim.net  – A reference to the FastNet object\nsim.t – Current time of the simulation\nsim.Tend – End time of the simulation\nsim.nodedigits – The expected number of characters needed to display node counts\nsim.linkdigits – The expected number of characters needed to display link counts\nsim.timedigits – The expected number of characters needed to display the simulation time  \nsim.timedec – The expected number of decimal places to needed to approximately show simulation time\nsim.Nout – a counter containing the number of the current output\nsim.results – the DataFrame where results should go\nsim.filename – the savefilename passed to sim during creation. Empty string, if no name as passed.\nsim.printresults – see below  ","category":"page"},{"location":"customization.html","page":"Customization","title":"Customization","text":"The printresults field contains either true, if output should be printed to the terminal, false if no output should be printed to the terminal or an IOStream to which terminal output should be redirected. ","category":"page"},{"location":"customization.html","page":"Customization","title":"Customization","text":"Information about the network can be gained by calling the typeical functions (countnodes, etc.) on sim.net. In addition the FastNet object sim.net contains two fields that may be useful","category":"page"},{"location":"customization.html","page":"Customization","title":"Customization","text":"sim.net.nodealias – A Vector of strings containing names for the node states\nsim.net.linkalias – A Vector of strings containing names for the tracked link states","category":"page"},{"location":"customization.html#FastNet-without-FastSim","page":"Customization","title":"FastNet without FastSim","text":"","category":"section"},{"location":"customization.html","page":"Customization","title":"Customization","text":"If you want to change the nature of the simulation, e.g. to introduce events happing after fixed time delays  or if you want fixed timesteps instead of the event-driven simulation you can't use FastSim, but you may still  want to use FastNet to keep track of the network. Allowing this split was the main reason for having two structures  instead of one. ","category":"page"},{"location":"tutorial.html#Fastnet.jl-Tutorial-–-SIS-Model","page":"Tutorial","title":"Fastnet.jl Tutorial – SIS Model","text":"","category":"section"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"In this tutorial we are going to build an epidimological SIS model","category":"page"},{"location":"tutorial.html#The-SIS-Model","page":"Tutorial","title":"The SIS Model","text":"","category":"section"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"The SIS model describes the spreading of an epidemic disease across a social network. The network nodes represent individuals, whereas the links represent repeated contacts between individuals that allow the disease to spread.   At all times each node is in either of two states: susceptible (S) or it is infected (I). ","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"The system changes in time due to two processes: ","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"For every link that connects an infected to a susceptible node (SI-link) there is a chance that the disease is transmitted to the susceptible node. Such transmissions occur at a rate p per SI-link. \nInfected nodes recover in time, returning to the susceptible state (there is no period of immunity after recovery). Such recovery events occur at the rate r per infected node. ","category":"page"},{"location":"tutorial.html#Preparations","page":"Tutorial","title":"Preparations","text":"","category":"section"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"We now write a short program that simulates the SIS model using Fastnet. We start by invoking the package and and defining some helpful constants","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"using Fastnet\r\n\r\nconst S=1                   # Node state 1: Susceptible node\r\nconst I=2                   # Node state 2: Infected node\r\nconst SI=1                  # Link state 1: Susceptible-Infected link \r\n\r\nconst p=0.05                # Infection rate (per SI-link)\r\nconst r=0.1                 # Recovery rate (per I-node)","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"The first line just tells Julia that we want to use the Fastnet package. The package will keep track of the network including the node and link states for us. However as developers we must remember which state is which. In the following node state 1 will mean that the node is susceptible and node state 2 means that the node is infected. To avoid having to remember this we just define two constants S and I. From now on we can use these to refer to the node states. ","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"In addition to nodes also links have states, which depend on the nodes they connect. We are only interested in one of these link states, the SI-links, so the links that connect a susceptible to an infected node. We say that such links are in state one, more about this in a moment, but we already define a constant SI to mean 1. ","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"The final block in the code above defines two constants for the infection rate and the recovery rate. Again, we don't actually have to do this, but it is good style as it allows you to change these parameters quickly and cleanly if you want to explore the models behavior for different parameter values. ","category":"page"},{"location":"tutorial.html#Keeping-Track-of-Links","page":"Tutorial","title":"Keeping Track of Links","text":"","category":"section"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"Fastnet achieves linear-time performance by keeping track of links using an innovative data structure. To be able to do its job we need to tell the package which types of links it needs to keep track of specifically. We a describe links using the LinkType structure like this","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"SI_link=LinkType(S,I,2)     # This describes what we mean by SI-link ","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"The constructor of LinkType takes three parameters, the state of the node at the source of the link, the state of the node at the destination of the link, and whether the link should be considered as unidirectional or bidirectional.","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"Internally FastNet represents all links as directed links, as this does not incur any additional costs in terms of performance or memory. So we always refer to one endpoint as the source of the link and one endpoint as the destination. ","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"In our epidemic model the links are undirected so we tell Fastnet to ignore the directionality of the link, by passing 2 (= Bidirectional) as the third argument. The only other value that is allowed for this argument is 1 (= Unidirectional).","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"In summary, the code above describes what we mean by an SI_link: any link that connects a node in state S to an node in state I, regardless of direction of the link.  ","category":"page"},{"location":"tutorial.html#Making-the-network","page":"Tutorial","title":"Making the network","text":"","category":"section"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"We are now ready to set up the network which we create with the following code:","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"# Lets make a network of 1M nodes and 4M links, 2 node states, that keeps track of SI links\r\nnet=FastNet(1000000,4000000,2,[SI_link]; nodealias=[\"S\",\"I\"], linkalias=[\"SI\"])","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"The initial command constructs the data structure for the network itself. The first two arguments tell it how many nodes and links we want to have in the network at most. Here we go with one million links and four million nodes. (Don't worry, Fastnet is fast, even with a million nodes the simulation finishes in about a minute on my laptop). The thrid argument is the number of states that we allow for the nodes. ","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"The fourth argument is more interesting. It is an array of all the link types we want to keep track off. In our case this array contains only one link type, the SIlink type that we just defined. Because *SIlink* is the first entry in the array Fastnet will think of SI-links as link state 1.","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"The arguments discussed above are the only essential arguments for the network constructor. However, we include two more optional arguments to make the output prettier. These are implemented as named arguments. In Julia we can provide such named arguments in any order or not at all, but we have to state their name so that Julia knows which arguments we want to specify. One of the optional arguments is called nodealias, and it accepts a vector of strings. Fastnet will use these strings to refer to the node states in outputs. The second argument linkalias does the same job for links. So in summary the first command tells Julia that we want a network of up to 1M nodes, up to 4M links, where the nodes can be in either of two states, which want to be called S and I in outputs. We want Fastnet to keep track of links between nodes in state S and nodes in state I, and we want it to refer to those links as SI in outputs.    ","category":"page"},{"location":"tutorial.html#Setting-up","page":"Tutorial","title":"Setting up","text":"","category":"section"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"Now we have a network, but so far it is a null graph; it doesn't contain any nodes and links. We can bring it to life with a few more lines of code","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"randomgraph!(net)           # Initialize as ER-random graph (all nodes will be in state 1: S)\r\n\r\nfor i=1:20                  # Infect 20 nodes at random \r\n    node=randomnode(net,S)\r\n    nodestate!(net,node,I)\r\nend","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"If we call randomgraph! like this, without further arguments, it creates the maximal number of nodes and links allowed in this network. The network is created as an Erdos-Renyi random graph, so all the links are placed at random. Initially all nodes will be in state one which in our model means that they are susceptible. Also note that Fastnet follows a Julia convention that says that all functions that change their arguments should have a name ending in an exclamation mark.","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"To get our epidemic going we will need some infected, so we use a simple for loop to infect 20 nodes at random. In the loop we use randomnode to pick a node in state S at random from the network. Due to the magic of Fastnet, picking a random node like this is done in constant time, i.e. the time needed for this operation does not scale with the size of the network or the number of states at all. ","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"Once we have picked a random node we use nodestate! to change the state of the node to infected. The time required for this command scales with the number of link states that we keep track of and the degree of the node, but not on the overall size of the network. ","category":"page"},{"location":"tutorial.html#The-rates!-function","page":"Tutorial","title":"The rates! function","text":"","category":"section"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"Now that we have our network set up, it's time to get to the physics of the system, i.e.~the rules that will drive the dyanmics. A crucial part of an event-driven simulation is to calculate how fast the different processes run in the current state of the network (whatever that may be). In our SIS model we calculate these rate in the following function","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"function rates!(rates,t)    # This functins computes the rates of processes\r\n    infected=countnodes(net,I)        # count the infected nodes\r\n    activelinks=countlinks(net,SI)    # count the SI links\r\n    infrate=p*activelinks               # compute total infection rate\r\n    recrate=r*infected                  # compute total recovery rate \r\n    rates[1]=infrate                    # Return the values by filling the rates array\r\n    rates[2]=recrate\r\n    nothing\r\nend","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"In a Fastnet simulation the rates function takes two arguments, a vector that needs to be filled with the rates and the current time. Note that the function does not need to return the computed rates but instead fills them into the vector that is provided as an argument. This is done for performance reasons. In the rates! function performance is crucial as this function will be called many, many times in the simulation. ","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"To compute the node the current rate at which infection and recovery events are happening we need to know how many infected nodes and how many SI-links there are in the network. We find these numbers with the countnodes and countlinks functions, respectively. Despite their names, these functions do not actually need to count anything, the net knows the answer already, so they both work in constant time. ","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"We then compute our total infection rate by multiplying the numeber of SI-links with the p, the infection rate per SI-link. Likewise we find the total recovery rate by multiplying the number of infected nodes by r, the recovery rate per infected node. ","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"Finally we fill the rates vector with the results. Here we chose to put the infection rate in the first place in the array and the recovery rate in the second. Up to this point the numbering of processes was undetermined, but from now on we have to be consistent, so infection will be process 1 and recovery will be process 2 from now on. ","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"The final nothing tells Julia that the function does not have a return value. ","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"(One may wonder whether it would be more efficient to squeeze the six lines of code into two lines and avoid the definition of intermediate variables. The answer is generally no. Julia is a compiled language and the compiler will take care of such small scale optimizations for us, so it won't make a difference in performance. In this case the longer form makes the code more readable and makes it easier to fnd bugs.)","category":"page"},{"location":"tutorial.html#Implementing-the-processes","page":"Tutorial","title":"Implementing the processes","text":"","category":"section"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"As the final piece of our model we need to define what happens when the processes occur we do this by defining two more functions ","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"function recovery!()        # This is what we do when the recovery process is triggered\r\n    inode=randomnode(net,I)           # Find a random infected node\r\n    nodestate!(net,inode,S)           # Set the state of the node to susceptible\r\nend\r\n\r\nfunction infection!()       # This is what we do when the infection process is triggered\r\n    alink=randomlink(net,SI)          # Find a random SI link\r\n    src=linksrc(net,alink)            # Find the endpoints of the link\r\n    dst=linkdst(net,alink)\r\n    nodestate!(net,src,I)             # Set both endpoints of the link to infected\r\n    nodestate!(net,dst,I)              # this is quicker than finding who's infected \r\nend","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"If a recovery event occurs a random node recovers, so in our recovery! function we use randomnode to pick a node in state I at random. Then, we use nodestate! to set the state of that node to S. ","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"In an infection event the disease gets passed along a random SI-link, so we use randomlink to pick an SI link at random. Then we find the two endpoints of the link with linksrc and linkdst. We could then use an if statement to find out which one of the two endpoints is the susceptible node, but ifs create control hazards which aren't great for performance so its probably a bit quicker to set both of the endpoints to the infected state. (One of them was infected anyway and the other is the one that we need to infect.)","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"Again the fuctions used in our implementation of these processes run either in constant time (randomnode,randomlink,linksrc,linkdst), or they scale only with the degree of the affected node and the number of link states that we are tracking (nodestate!), hence the runtime required to simulate one event won't depend on the network size. Simulating a network for a finite time will still scale linearly with network size as larger networks have more nodes and links on which events can occur.  ","category":"page"},{"location":"tutorial.html#Simulation","page":"Tutorial","title":"Simulation","text":"","category":"section"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"Now that we have all the pieces, we can set up and run the simulation","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"sim=FastSim(net,rates!,[infection!,recovery!], saveas=\"result.csv\")   # initialize the simulation \r\n\r\n@time runsim(sim,60,5)      # Run for 60 timeunits (reporting every 5)","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"The first of these lines actually sets up the simulation. The essential arguments of the simulation constructor are the network, our rates! function and a vector containing the functions that implement the processes. ","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"Note that the order of function in the third argument is not arbitrary. Recall that our rates! function returns the infection rate as the first elements of the rates vector. Therefore the infection! function also needs to be in the first spot in the argument.  ","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"The FastSim constructor has a number of named arguments. Here we use saveas to tell the simulation to save its results in a file called results.csv. If we don't specify this argument then the results won't be saved, but we can still get them from the sim as a DataFrame using the results function. ","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"Finally we run the simulation using the runsim command. It's essential arguments are the simulation and the amount of time that we want to simulate. The third, optional, argument specifies the interval at which results should be reported. (Of course our primal instincts tell us to get as much data out as we possibly can, but its a good idea to resist these urges. If your aim is to get a nice plot of the results you will typically have a better results and a be a happier person if your result files contain 50 points rather than 500. Just sayin'.)","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"Before the runsim I have added Julia's @time macro which times the performance of the function. This is often useful information to have. If you find that the present code runs in about a minute or so, you might decide that you would like to run a simulation on 10M nodes and 40M links instead. Because everything else being the same your 10M node simulation should take about the 10 minutes, so enough time for a coffee if you are quick. ","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"But before we run really large simulations we should make one final improvement...","category":"page"},{"location":"tutorial.html#Faster-functions","page":"Tutorial","title":"Faster functions","text":"","category":"section"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"To help with debugging, functions such as nodestate! carry out a number of checks and try to provide meaningful error message if their arguments look iffy. This comes at a price in terms of performance. Because your rates and process functions might be called billions of times in large simulations, you may want to avoid these extra checks. For this purpose Fastnet provides faster implementations for some of the key functions. The names of these functions are identical to the other function names with an added _f at the end, so in addion to nodestate! there is also ","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"nodestate_f!(net::FastNet,node,newstate)","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"This function is identical to nodestate! but avoids some of the safety checks. Likewise such fast implementations also exist for most of the other functions that you would use in your rates! and process functions. So once we are happy with our program and have run it a few times, we can speed it up a little bit by changing the rates! and process functions to   ","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"function rates!(rates,t)                # This functins computes the rates of processes\r\n    infected=countnodes_f(net,I)                # count the infected nodes\r\n    activelinks=countlinks_f(net,SI)            # count the SI links\r\n    infrate=p*activelinks                       # compute total infection rate\r\n    recrate=r*infected                          # compute total recovery rate \r\n    rates[1]=infrate                            # Return the values by filling the rates array\r\n    rates[2]=recrate\r\n    nothing\r\nend\r\n\r\nfunction recovery!()                    # This is what we do when the recovery process is triggered\r\n    inode=randomnode_f(net,I)                   # Find a random infected node\r\n    nodestate_f!(net,inode,S)                   # Set the state of the node to susceptible\r\nend\r\n\r\nfunction infection!()                   # This is what we do when the infection process is triggered\r\n    alink=randomlink_f(net,SI)                   # Find a random SI link\r\n    nodestate_f!(net,linksrc_f(net,alink),I)     # Set both endpoints of the link to infected\r\n    nodestate_f!(net,linkdst_f(net,alink),I)    \r\nend","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"The performance increase is not huge (ca.~20%), so don't feel bad about using the functions without the _f at first, but in large simulations the form with the _f may save some time and energy. ","category":"page"},{"location":"tutorial.html#Full-example-code","page":"Tutorial","title":"Full example code","text":"","category":"section"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"The final version of the complete code looks like this ","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"\r\nusing Fastnet\r\n\r\nconst S=1                               # Node state 1: Susceptible node\r\nconst I=2                               # Node state 2: Infected node\r\nconst SI=1                              # Link state 1: Susceptible-Infected link \r\n\r\nconst p=0.05                            # Infection rate (per SI-link)\r\nconst r=0.1                             # Recovery rate (per I-node)\r\n\r\nSI_link=LinkType(S,I,2)                 # This describes what we mean by SI-link \r\n\r\n# Let's make a network of 1M nodes and 4M links, 2 node states, that keeps track of SI links\r\nnet=FastNet(1000000,4000000,2,[SI_link]; nodealias=[\"S\",\"I\"], linkalias=[\"SI\"])\r\n\r\nrandomgraph!(net)                       # Initialize as ER-random graph (all nodes will be in state 1: S)\r\n\r\nfor i=1:20                              # Infect 20 susceptible nodes at random \r\n    node=randomnode(net,S)\r\n    nodestate!(net,node,I)\r\nend\r\n\r\nfunction rates!(rates,t)                # This functins computes the rates of processes\r\n    infected=countnodes_f(net,I)                # count the infected nodes\r\n    activelinks=countlinks_f(net,SI)            # count the SI links\r\n    infrate=p*activelinks                       # compute total infection rate\r\n    recrate=r*infected                          # compute total recovery rate \r\n    rates[1]=infrate                            # Return the values by filling the rates array\r\n    rates[2]=recrate\r\n    nothing\r\nend\r\n\r\nfunction recovery!()                    # This is what we do when the recovery process is triggered\r\n    inode=randomnode_f(net,I)                   # Find a random infected node\r\n    nodestate_f!(net,inode,S)                   # Set the state of the node to susceptible\r\nend\r\n\r\nfunction infection!()                   # This is what we do when the infection process is triggered\r\n    alink=randomlink_f(net,SI)                   # Find a random SI link\r\n    nodestate_f!(net,linksrc_f(net,alink),I)     # Set both endpoints of the link to infected\r\n    nodestate_f!(net,linkdst_f(net,alink),I)    \r\nend\r\n\r\nsim=FastSim(net,rates!,[infection!,recovery!])   # initialize the simulation \r\n\r\n@time runsim(sim,60.0,5.0)                       # Run for 60 timeunits (reporting every 5)\r\n","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"The code can also be found here.","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"Some more examples for other models can be found in the same here.","category":"page"},{"location":"tutorial.html#Running-the-example-code","page":"Tutorial","title":"Running the example code","text":"","category":"section"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"If you are new to Julia one of the simplest ways to get this code to work is ","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"Install Julia \nInstall Fastnet from Julia (as described on the welcome page)\nExit Julia and download the SIS.jl","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"You can then run the SIS.jl either from your console using ","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"julia \"SIS.jl\"","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"or form Julia's REPL by executing ","category":"page"},{"location":"tutorial.html","page":"Tutorial","title":"Tutorial","text":"include(\"SIS.jl\")","category":"page"},{"location":"concepts.html#Key-concepts","page":"Key Concepts","title":"Key concepts","text":"","category":"section"},{"location":"concepts.html#Accessing-nodes-and-links","page":"Key Concepts","title":"Accessing nodes and links","text":"","category":"section"},{"location":"concepts.html","page":"Key Concepts","title":"Key Concepts","text":"In Fastnet there are two ways to refer to a specific network node:","category":"page"},{"location":"concepts.html","page":"Key Concepts","title":"Key Concepts","text":"Node ID – Every node has a unique id number that never changes. The id number may be recycled if a node is destroyed and later another node is created. All id numbers are integers between in the range 1:N, where N is the maximal node number that was passed to the FastNet constructor when the network was created. Node IDs are not necessarily consecutive so a network containing two nodes could contain the nodes with ids 17 and 23 for example. ","category":"page"},{"location":"concepts.html","page":"Key Concepts","title":"Key Concepts","text":"Node state and position – We can also identify nodes by saying \"the n'th node in state x\" where n is one of the allowed node states and x is the so-called positon in this state. So in the epidemic model from the tutorial we might say we want the first infected node. A state-position pair will not always refer to the same node, but the positions are always numbered consecutively, so if there are 2 infected node these will have the positions 1 and 2 in the infected state.","category":"page"},{"location":"concepts.html","page":"Key Concepts","title":"Key Concepts","text":"In general the FastNet functions expect you to refer to nodes by node ID. However, class and position is useful for example if you want to iterate over all nodes in a certain state. You can obtain the id of a node at a certain position using the function ","category":"page"},{"location":"concepts.html","page":"Key Concepts","title":"Key Concepts","text":"node(net,ste,pos)","category":"page"},{"location":"concepts.html","page":"Key Concepts","title":"Key Concepts","text":"which returns the node ID for the node at position pos of state ste in the network net.","category":"page"},{"location":"concepts.html","page":"Key Concepts","title":"Key Concepts","text":"Links are addressed in the same way. In addition to the different link states specified in the network construction there is one additional link state that means \"any other link\". For example if you told Fastnet to track three particular link states, these will be states number 1 to 3 and any other link will be in state number 4. The ID of a link can be found by  ","category":"page"},{"location":"concepts.html","page":"Key Concepts","title":"Key Concepts","text":"link(net,ste,pos)","category":"page"},{"location":"concepts.html","page":"Key Concepts","title":"Key Concepts","text":"which returns the link ID for the link at position pos of state ste in the network net.","category":"page"},{"location":"concepts.html#Network-representation","page":"Key Concepts","title":"Network representation","text":"","category":"section"},{"location":"concepts.html","page":"Key Concepts","title":"Key Concepts","text":"Technical speaking the network described by Fastnet is a directed pseudograph.","category":"page"},{"location":"concepts.html","page":"Key Concepts","title":"Key Concepts","text":"We call the network a pseudograph because it is not a simple graph, i.e. it can contain self-loops and multilinks.  So there can in principle be a link that connects a node to itself and a given pair of nodes can be connected by multiple links. ","category":"page"},{"location":"concepts.html","page":"Key Concepts","title":"Key Concepts","text":"The network as been implemented in this way mainly to improve the efficiency of models that should almost always remain simple graphs. Allowing the occasional multi-link or self-loop eliminates the need for constant checking if a given operation would make the graph non-simple. By contrast models that make extensive use of self-loops or multi-links are rare. As a result this feature presently remains a bit undertested, so use with caution.","category":"page"},{"location":"concepts.html","page":"Key Concepts","title":"Key Concepts","text":"In the underlying data structure of Fastnet, every link is represented as a directed link (an arc in math-speak). This comes at no addional computational or memory cost and actually makes many nuances of the implementation easier.  Nevetheless the package has been developed with undirected networks in mind and we can often simply ignore the underlying directedness of links. What this means is that Fastnet can be used to implement models that use directed links, models that use undirected (or bidirectional) links, and even models that mix the two types. ","category":"page"},{"location":"concepts.html","page":"Key Concepts","title":"Key Concepts","text":"One (mildly beneficial) effect of the directed nature of links is that there is a unique way to refer to the nodes at the end of the link. They can be determined by the functions ","category":"page"},{"location":"concepts.html","page":"Key Concepts","title":"Key Concepts","text":"linksrc(net,lnk)\r\nlinkdst(net,lnk)","category":"page"},{"location":"concepts.html","page":"Key Concepts","title":"Key Concepts","text":"which return the node ids that are at the source and destination, respectively, of link with id lnk in network net. ","category":"page"},{"location":"concepts.html#Slow-and-Fast-functions","page":"Key Concepts","title":"Slow and Fast functions","text":"","category":"section"},{"location":"concepts.html","page":"Key Concepts","title":"Key Concepts","text":"In programming there is always a certain extent to which simplicity and elegance of implementation benefit both the debuggability and performance of code. In Fastnet we go beyond this point in terms of debuggability. In an attempt to provide meaningful safty checks and error messages most functions carry out some additional checks that incur a performance cost. This is great for debugging (I sinceserly hope), but if we want to run very large simulations we might wish that these extra checke were not done. For this purpose Fastnet provides an alternative implementation for many functions that forego the safty checks to achieve greater performance. ","category":"page"},{"location":"concepts.html","page":"Key Concepts","title":"Key Concepts","text":"The performance optimised functions are named in the same way as their corresponding parteners with an additional _f appendend to the name. So for example the two functions ","category":"page"},{"location":"concepts.html","page":"Key Concepts","title":"Key Concepts","text":"node(net,ste,pos)\r\nnode_f(net,ste,pos)","category":"page"},{"location":"concepts.html","page":"Key Concepts","title":"Key Concepts","text":"behave exactly identically, except that the former one carries out the additional checks. ","category":"page"},{"location":"concepts.html","page":"Key Concepts","title":"Key Concepts","text":"In Julia the names of functions that change their arguments typically end in an exclamation mark. In this case the _f goes before the exclamation mark. The functions ","category":"page"},{"location":"concepts.html","page":"Key Concepts","title":"Key Concepts","text":"nodestate!(net,nde,s)\r\nnodestate_f!(net,nde,s)","category":"page"},{"location":"concepts.html","page":"Key Concepts","title":"Key Concepts","text":"which are used to change the state of the node nde to state s and an example of such a pair.  ","category":"page"},{"location":"concepts.html","page":"Key Concepts","title":"Key Concepts","text":"The speedup from using the fast fucntions is not huge (ca. 20%) but it can be worthwhile in large simulation runs, especially in your rates! and process functions (see tutorial). The recommended workflow is to implement your model with the safe functions first and change some of the functions to fast versions once the code has run for a couple of times. ","category":"page"},{"location":"concepts.html","page":"Key Concepts","title":"Key Concepts","text":"Calling fast functions with the wrong arguments can lead to unexpected behavior and might in rare cases crash Julia.","category":"page"},{"location":"about.html#About-Fastnet","page":"About","title":"About Fastnet","text":"","category":"section"},{"location":"about.html","page":"About","title":"About","text":"The Fastnet package was developed by Thilo Gross at the Helmholtz Institute for Functional Mariene Diversity (HIFMB) in Oldenburg Germnany.","category":"page"},{"location":"about.html#Funding","page":"About","title":"Funding","text":"","category":"section"},{"location":"about.html","page":"About","title":"About","text":"Thilo's work is funded by the Ministry for Science and Culture of Lower Saxony (MWK) and the Volkswagen Foundation through the “Niedersächsisches Vorab” grant program (grant number ZN3285).","category":"page"},{"location":"about.html#Publication","page":"About","title":"Publication","text":"","category":"section"},{"location":"about.html","page":"About","title":"About","text":"The package is also decribed in the following publication:","category":"page"},{"location":"about.html","page":"About","title":"About","text":"TBA","category":"page"},{"location":"about.html#Contact","page":"About","title":"Contact","text":"","category":"section"},{"location":"about.html","page":"About","title":"About","text":"You can contact Thilo by email (thilo@gross@gmail.com) or using the snail mail address below","category":"page"},{"location":"about.html","page":"About","title":"About","text":"Prof. Dr. Thilo Gross\r\nHIFMB\r\nAmmerländer Heerstr. 231\r\n26129 Oldenburg \r\nGermany","category":"page"},{"location":"about.html#About-the-name","page":"About","title":"About the name","text":"","category":"section"},{"location":"about.html","page":"About","title":"About","text":"This package is called Fastnet because it can simulate networks fast. However the name is also reminds of Fastnet rock. A small rocky island off the Irish coast that boasts a distinctive lighthoese. Before the lighthouse was built, many sailors died in wrecks on this lonely rock. This image serves as a reminder of our solidarity that blooms in harsh environments and our ability to make the world a better, safer place by making contributions toward a common good. One way to make such a contribution today is to advance humanity's knowledge and capabilites through freely accessible research and free software. If you use Fastnet, consider making also the results of your work freely available. Please build a lighthouse on the foundations I laid by providing this package.    ","category":"page"},{"location":"background.html#Background-Event-driven-simulation","page":"Background","title":"Background - Event driven simulation","text":"","category":"section"},{"location":"background.html","page":"Background","title":"Background","text":"This section contains some background information about the way in which fastnet simulates networks. You won't need to know any of this to use Fastnet, but if you are interested what is under the hood, please read on. ","category":"page"},{"location":"background.html#How-to-simulate-processes-on-networks","page":"Background","title":"How to simulate processes on networks","text":"","category":"section"},{"location":"background.html","page":"Background","title":"Background","text":"If we think about simulating processes on networks, the first idea that usualluy comes to mind are to update all nodes simulataneously in small time steps. This idea is attractive because it makes thinking about the simulation seemingly easier, however it entails a number of problemns","category":"page"},{"location":"background.html","page":"Background","title":"Background","text":"Update order – How do we actually implement our timesteps? Do we update every node in every timestep? And if so in which order do we update them. If the order is always the same we will create artifacts (unrealistic artifical behavior), so we need to randomize. But such randomization can lead to further problems, for instance do we keep track of who has already been updated etc.  ","category":"page"},{"location":"background.html","page":"Background","title":"Background","text":"Collisions – What do we do if different events that occur in one timestep are contradictory? For example what if a node in an epidemic situation infects another node and recovers from the disease at the same time. Does the infection always go first? Or can the recovery occur first making the infection event impossible? ","category":"page"},{"location":"background.html","page":"Background","title":"Background","text":"Timeing artifacts – Even if we find elegant solutions for event collisions and update order, we are still approximating a real-word system in which time flows continously by a model in which time proceeds in discrete steps. This in itself can cause some artifacts. For example it can lead to the formation of certain patterns which won't occur in the continuous time system.  ","category":"page"},{"location":"background.html","page":"Background","title":"Background","text":"Efficiency – The most common solution to the problems above is to make timesteps tiny. While this lessens the impact of the artifacts it does not prevent them altogether. Moreover, it comes at a high coast in terms of efficiency. We will need to simulate many timesteps to cover the desired stretch of time, and in each of these steps we will be checking a large number of nodes for possible updates. However, since out timesteps are now tiny the probability that a given node is affected by an event in a given timestep is tiny, often in below 1 in a million. This means we spent a lot of computation time to do updates on nodes in which nothing changes at all.  ","category":"page"},{"location":"background.html","page":"Background","title":"Background","text":"Simulations that work with discrete timesteps can still be a good idea if the underlying system fundamentally works in discrete timesteps. However, in the vast majority of cases we can simulate systems better, faster, and more elgantly by not using timesteps at all...","category":"page"},{"location":"background.html#The-Gillespie-Algorithms","page":"Background","title":"The Gillespie Algorithms","text":"","category":"section"},{"location":"background.html","page":"Background","title":"Background","text":"In 1976 Daniel T. Gillespie published the idea for an event-driven simulation algorithm","category":"page"},{"location":"background.html","page":"Background","title":"Background","text":"Gillespie (1976). \"A General Method for Numerically Simulating the Stochastic Time Evolution of Coupled Chemical Reactions\". Journal of Computational Physics. 22 (4): 403–434.","category":"page"},{"location":"background.html","page":"Background","title":"Background","text":"The basic idea is that the simulation code will consider the system and then determine (stochastically) which event will happen next in the system and at which time this event will occur. The simulation then jumps forward directly to the time point where the next event occurs and implements the consequences of this event. Once the model has been updated in this way the simulation considers it again to determine what the next event is, and so on. ","category":"page"},{"location":"background.html","page":"Background","title":"Background","text":"With Gillespie's algorithm events can never collide. Moreover there can be no articfacts due to timesteps, because there are no discrete timesteps. Also, the simulation is highly efficient because no time is wasted between events.  As a result Gillespie-style event-driven simulations combine excellent performance with a high degree of realism. ","category":"page"},{"location":"background.html#Making-it-fast","page":"Background","title":"Making it fast","text":"","category":"section"},{"location":"background.html","page":"Background","title":"Background","text":"The heart of any event driven simulation are a number of functions. One of these is used to calculate the rates at which processes occur given the state in the system (the rates! function). The others implement the individual processes that can occur in the system. ","category":"page"},{"location":"background.html","page":"Background","title":"Background","text":"The key to making event-driven simulations fast is to make sure that these core functions can run without needing to consider (e.g. without needing to iterate over all network nodes). Fastnet makes achieves this by clever bookkeeping that makes use of an innovative data structure. Using this bookkeeping, the tools one needs in a network simulation such as ","category":"page"},{"location":"background.html","page":"Background","title":"Background","text":"finding the number of nodes or links in a certain state, \nrandomly picking a node of link in a certain state at random,  \ncreating or removing nodes or links\nchanging the state of nodes","category":"page"},{"location":"background.html","page":"Background","title":"Background","text":"can all be implemented such that their runtimes is independent of the number of nodes or links in the network. In Fastnet all of these functions either run in constant time, or scale only with the degree of the affected node and the number of states. ","category":"page"},{"location":"background.html","page":"Background","title":"Background","text":"The basic idea for the bookkeeping used in Fastnet was born while we were working on the following publication:","category":"page"},{"location":"background.html","page":"Background","title":"Background","text":"T. Gross, C.J. Dommar D’Lima and B. Blasius (2006) \"Epidemic dynamics on an adaptive network.\" Phys. Rev. Lett. 96, 208701.","category":"page"},{"location":"background.html","page":"Background","title":"Background","text":"The underlying datastructure that makes the bookkeeping possible is also available in Julia, on its own in the Repos package Fastnet does not use this package but rather reimplements the Repos structure in an opimized way for its current application. ","category":"page"},{"location":"reference.html#Function-Reference","page":"Function Reference","title":"Function Reference","text":"","category":"section"},{"location":"reference.html#Constructors","page":"Function Reference","title":"Constructors","text":"","category":"section"},{"location":"reference.html","page":"Function Reference","title":"Function Reference","text":"LinkType\r\nFastNet\r\nFastSim","category":"page"},{"location":"reference.html#Fastnet.LinkType","page":"Function Reference","title":"Fastnet.LinkType","text":"LinkType(from,to,dir=2)\n\nCreate a LinkType structure that describes the properties of a type of link in the network. \n\nThink of a LinkType as a set of criteria that describe a certain sort of link. The first two arguments  specify the states of the nodes at the start and end of the link respectively. The third argument specified if the LinkType can either be 1 or 2, where dir=1 signifies that the link type should be interpreted as directed (unidirectional) and dir=2 signifies that it should be interpreted as undirected (bidirectional). \n\nThe state of the node at the start and end of this type of link can be specified in different ways.  A value of 0 or * for from or to means that the respective node can be in any state. An integer value corresponding to a node state means that the node must be in the respective state. An Array or Tuple of Ints means that the  node must be in one of the states listed.    \n\nExamples\n\njulia> using Fastnet\n\njulia> LinkType(3,4)\nLinks of the form:  (3) --- (4)\n\njulia> LinkType(3,4,1)\nLinks of the form:  (3) --> (4)\n\njulia> LinkType(3,4,2)\nLinks of the form:  (3) --- (4)\n\njulia> LinkType(\"*\",4)\nLinks of the form:  (any) --- (4)\n\njulia> LinkType(4,0)\nLinks of the form:  (4) --- (any)\n\njulia> LinkType((1,2),3)\nLinks of the form:  (1/2) --- (3)\n\njulia> LinkType(4,[1,2],1)\nLinks of the form:  (4) --> (1/2)\n\n\n\n\n\n","category":"type"},{"location":"reference.html#Fastnet.FastNet","page":"Function Reference","title":"Fastnet.FastNet","text":"FastNet(n,k,c,tlist;<keyword arguments>)\n\nCreate a FastNet object that represents a network structe.\n\nMemory will be allocated for up to n nodes, up to k links. Nodes can be in one of c different states.\n\nThe argument tlist is an array or tuple of LinkType. This list tells the networks which types of links are  important for you. For example in an epidemic simulation the we are particularly interested in links between  infected and susceptible nodes. FastNet will do the necessary bookkeeping, to enable very fast counting, selection, etc. of the links that are in a state listed in tlist. \n\nNote that the order of elements of tlist is not arbitrary. FastNet will think of links that match the first element  of tlist as being in link state 1. The links that match the sceond type in link state 2, and so on. \n\nWARNING: Each link in the network can only be in any one state at any time passing a tlist that contains overlapping  link types (e.g. [LinkType([1,2],3),LinkType(3,1)] )  will result in an ArgumentError being thrown. \n\nFastNet supports a number of optional keyword arguments:\n\nnodealias : a vector of strings that will be used as names of node states in outputs\nlinkalias : a vector of strings that will be used as names of link states in outputs\nrng : specifies a custom random number generator\n\nThe network will initially be empty (i.e. a null graph)\n\nExamples\n\njulia> using Fastnet\n\njulia> FastNet(10,9,1,[])\nNetwork of 0 nodes and 0 links\n\njulia> FastNet(100,1000,3,[LinkType(1,2),LinkType(3,\"*\",1)])\nNetwork of 0 nodes and 0 links\n\njulia> using Random\n\njulia> mt = MersenneTwister(1234);\n\njulia> const S=1;\n\njulia> const I=2;\n\njulia> SI_link=LinkType(S,I)\nLinks of the form:  (1) --- (2)\n\njulia> net=FastNet(10000,60000,2,[SI_link],nodealias=[\"S\",\"I\"],linkalias=[\"S-I\"],rng=mt)\nNetwork of 0 nodes and 0 links\n\n\n\n\n\n","category":"type"},{"location":"reference.html#Fastnet.FastSim","page":"Function Reference","title":"Fastnet.FastSim","text":"FastSim(net,rates!,processes;<keyword arguments>)\n\nCreate a FastSim structure, representing a FastNet simulation run. \n\nThe first argument net is a FastNet structure that is be used in the simulation. \n\nThe second argument is the rates! function of the simulation. The rates function is a function  that accepts two arguments. The first of these arguments is an MVector{Float64}  (see StaticArrays Documentation for details). The second argument is a the current time in the simulation. \n\nWhen the rates! function is called it should compute the total rates of at which the different processes  occur in the system, given the current state of the network. The rates functions returns these values by  filling the array that was passed as the first argument. The rates! should not have a return value. \n\nNote that when rates are time dependent then the rates! function should use the time value passed to it rather  than obtaining a time form the simulation structure. The simulation code assumes that the rates will remain  constant until the next event. This should be harmless in almost all cases but can cause inaccuracy if your  rates depend explicitely on time, the rates are very senstitive to time and events are rare. \n\nThe third argument is a Vector of functions that implements the processes. The processes are functions  without arguments when they are called they should implement effect of the respecive process running once. Note that elemets of the process function vector should be in the same order as the corresponding rates computed by  the rates! vector.\n\nFastSim supports a number of optional keyword arguments:\n\nsaveas : A String specifying the pathname where results should be saved. If unspecified results aren't saved but can be optained using the results function.\noutput : a boolean variable that specifies if results should be printed on the console, by default this is true.  Alternatively also an IOStream can be provided to which results should be written. \nrepfunc : This argument can be used to specify an alternative function to generate outputs and store results.  See custimization for details. \n\nExamples\n\njulia> using Fastnet\n\njulia> const Bored=1; const Excited=2;\n\njulia> net=FastNet(1000,5000,2,[LinkType(Excited,Bored,1)]);\n\njulia> randomgraph!(net);\n\njulia> function rates!(rates,t)\n         rates[1]=countlinks(net,1)*0.1\n         rates[2]=countnodes(net,Excited)*0.2\n         rates[3]=countnodes(net,Bored)*0.001\n         end;\n\njulia> function excitement_spreads()\n         link=randomlink(net,1)\n         nodestate!(net,linkdst(net,link),Excited)\n         end;\n\njulia> function get_bored()\n         node=randomnode(net,Excited)\n         nodestate!(net,node,Bored)\n         end;\n\njulia> function great_idea()\n         node=randomnode(net,Bored)\n         nodestate!(net,node,Excited)\n         end;\n\njulia> sim=FastSim(net,rates!,[excitement_spreads,get_bored,great_idea])\nSimulation run, currently at time 0.0\n\n\n\n\n\n","category":"type"},{"location":"reference.html#Network-Setup","page":"Function Reference","title":"Network Setup","text":"","category":"section"},{"location":"reference.html","page":"Function Reference","title":"Function Reference","text":"nullgraph!\r\nrandomgraph!","category":"page"},{"location":"reference.html#Fastnet.nullgraph!","page":"Function Reference","title":"Fastnet.nullgraph!","text":"nullgraph!(net)\n\nRemove all nodes and links from the network. \n\nThe first argument net is a FastNet structure that is be used in the simulation. \n\nExamples\n\njulia> using Fastnet\n\njulia> net=FastNet(1000,2000,1,[])\nNetwork of 0 nodes and 0 links\n\njulia> randomgraph!(net)\nNetwork of 1000 nodes and 2000 links\n\njulia> nullgraph!(net)\nNetwork of 0 nodes and 0 links\n\n\n\n\n\n","category":"function"},{"location":"reference.html#Fastnet.randomgraph!","page":"Function Reference","title":"Fastnet.randomgraph!","text":"randomgraph!(net;<keyword arguments>)\n\nCreate an ER random graph in the network net. \n\nThe network isn't guaranteed to be a simple graph, but in large sparse  networks it is simple with high probability. \n\nBy default all nodes and links that the network can accommodate will be used and  all nodes will be set to state one. This behavior can be controlled by the following  keyword arguments:\n\nN : The number of nodes that will be used in the creation of the random graph. All other nodes will be removed from the network. \nK : The number of links that will be used in the creation of the random graph. All other links will be removed from the network. \nS : The state of the nodes. All nodes will be set to this state. \n\nExamples\n\njulia> using Fastnet\n\njulia> net=FastNet(1000,2000,1,[])\nNetwork of 0 nodes and 0 links\n\njulia> randomgraph!(net)\nNetwork of 1000 nodes and 2000 links\n\njulia> nullgraph!(net)\nNetwork of 0 nodes and 0 links\n\njulia> randomgraph!(net,N=100,K=10)\nNetwork of 100 nodes and 10 links\n\n\n\n\n\n","category":"function"},{"location":"reference.html#Node-Functions","page":"Function Reference","title":"Node Functions","text":"","category":"section"},{"location":"reference.html","page":"Function Reference","title":"Function Reference","text":"Fastnet.adjacent\r\ncountnodes\r\ndegree\r\ndestroynode!\r\nfirstlinkin\r\nfirstlinkout\r\nindegree\r\nmakenode!\r\nmakenodes!\r\nnode\r\nnodecounts\r\nnodeexists\r\nnodestate\r\nnodestate!\r\noutdegree\r\nrandomnode","category":"page"},{"location":"reference.html#Fastnet.adjacent","page":"Function Reference","title":"Fastnet.adjacent","text":"adjacent(net,a,b)\nadjacent_f(net,a,b)\n\nCheck if nodes with the id's a and b are adjacent in network net. If they are  return the id a of the link connecting them. Otherwise return 0.\n\nIf multiple links connect the nodes the function will return a link in the direction  a->b if such a link exists. \n\nCalling adjacent(net,a,a) will return a self-loop on a if one exists. \n\nThe worst case performance of this function scales with the degree of node a. The fast (_f) verions sacrifice some safty checks for better performance.  See basic concepts for details. \n\nExamples\n\njulia> using Fastnet\n\njulia> net=FastNet(1000,2000,2,[])\nNetwork of 0 nodes and 0 links\n\njulia> makenodes!(net,100,1);\n\njulia> net\nNetwork of 100 nodes and 0 links\n\n\n\n\n\n","category":"function"},{"location":"reference.html#Fastnet.countnodes","page":"Function Reference","title":"Fastnet.countnodes","text":"countnodes(net)\ncountnodes(net,s)\ncountnodes_f(net)\ncountnodes_f(net,s)\n\nCount the nodes in state s, or, if no state is provided, in the entire network.  \n\nInstead of the state s also an Array or Tuple of states can be passed.  In this case the total number of nodes in all of the listed states is returned. \n\nAll versions of this function run in constant time.  The fast (_f) verions sacrifice some safty checks for better performance.  See basic concepts for details. \n\nIf performance is critical use this function rather than nodecounts.\n\nSee also nodecounts\n\nExamples\n\njulia> using Fastnet\n\njulia> net=FastNet(1000,2000,2,[])\nNetwork of 0 nodes and 0 links\n\njulia> for i=1:20\n         makenode!(net,1)\n         end\n\njulia> for i=1:10\n         makenode!(net,2)\n         end\n\njulia> countnodes(net)\n30\n\njulia> countnodes(net,1)\n20\n\njulia> countnodes(net,(1,2))\n30\n\n\n\n\n\n","category":"function"},{"location":"reference.html#Fastnet.degree","page":"Function Reference","title":"Fastnet.degree","text":"degree(net,nid)\ndegree_f(net,nid)\n\nReturn the degree of the node with id nid in network net.  \n\nHere degree is interpreted as the number of times this node appears an an endpoint of a link, hence self-loops contribute 2 to the degree of the node that they link to. \n\nThe worst case performance scales only with the degree of the affected node.  The fast (_f) verions sacrifice some safty checks for better performance.  See basic concepts for details. \n\nSee also indegree, outdegree \n\nExamples\n\njulia> using Fastnet\n\njulia> net=FastNet(1000,2000,2,[])\nNetwork of 0 nodes and 0 links\n\njulia> n1=makenode!(net,1);\n\njulia> n2=makenode!(net,1);\n\njulia> n3=makenode!(net,1);\n\njulia> makelink!(net,n1,n2);\n\njulia> makelink!(net,n2,n3);\n\njulia> degree(net,n1)\n1\n\njulia> degree(net,n2)\n2\n\n\n\n\n\n","category":"function"},{"location":"reference.html#Fastnet.destroynode!","page":"Function Reference","title":"Fastnet.destroynode!","text":"destroynode!(net,nid)\ndestroynode_f!(net,nid)\n\nDestroy the node with id nid in network net. \n\nWorst-case performance of both versions of this function is O(ks*k)+O(ns) where ks is the number of  tracked link states, k is the degree of the affected node and ns is the number of node states.  \n\nThe fast (_f) verions sacrifice some safty checks for better performance.  See basic concepts for details. \n\nSee also makenode!\n\nExamples\n\njulia> using Fastnet\n\njulia> net=FastNet(1000,2000,2,[])\nNetwork of 0 nodes and 0 links\n\njulia> n=makenode!(net,1);\n\njulia> net\nNetwork of 1 nodes and 0 links\n\njulia> destroynode!(net,n)\n\njulia> net\nNetwork of 0 nodes and 0 links\n\n\n\n\n\n","category":"function"},{"location":"reference.html#Fastnet.firstlinkin","page":"Function Reference","title":"Fastnet.firstlinkin","text":"firstlinkin(net,nid)\nfirstlinkin_f(net,nid)\n\nReturn the link id of the first incoming link to the node with id nid in network net.  \n\nIf there are no incoming links then the return value is 0\n\nAll versions of this function run in constant time.  The fast (_f) verions sacrifice some safty checks for better performance.  See basic concepts for details. \n\nSee also firstlinkout, nextlinkin \n\nExamples\n\njulia> using Fastnet\n\njulia> net=FastNet(1000,2000,2,[])\nNetwork of 0 nodes and 0 links\n\njulia> n1=makenode!(net,1);\n\njulia> n2=makenode!(net,1);\n\njulia> l1=makelink!(net,n1,n2);\n\njulia> firstlink=firstlinkin(net,n2);\n\njulia> firstlink==l1\ntrue\n\njulia> linksrc(net,firstlink)==n1\ntrue\n\njulia> linkdst(net,firstlink)==n2\ntrue\n\n\n\n\n\n","category":"function"},{"location":"reference.html#Fastnet.firstlinkout","page":"Function Reference","title":"Fastnet.firstlinkout","text":"firstlinkout(net,nid)\nfirstlinkout_f(net,nid)\n\nReturn the link id of the first outgoing link from the node with id nid in network net.  \n\nIf there are no outgoing links then the return value is 0\n\nAll versions of this function run in constant time.  The fast (_f) verions sacrifice some safty checks for better performance.  See basic concepts for details. \n\nSee also firstlinkout, nextlinkin \n\nExamples\n\njulia> using Fastnet\n\njulia> net=FastNet(1000,2000,2,[])\nNetwork of 0 nodes and 0 links\n\njulia> n1=makenode!(net,1);\n\njulia> n2=makenode!(net,1);\n\njulia> l1=makelink!(net,n1,n2);\n\njulia> firstlink=firstlinkout(net,n1);\n\njulia> firstlink==l1\ntrue\n\njulia> linksrc(net,firstlink)==n1\ntrue\n\njulia> linkdst(net,firstlink)==n2\ntrue\n\n\n\n\n\n","category":"function"},{"location":"reference.html#Fastnet.indegree","page":"Function Reference","title":"Fastnet.indegree","text":"indegree(net,nid)\nindegree_f(net,nid)\n\nReturn the incoming degree of the node with id nid in network net.  \n\nThe worst case performance scales only with the indegree of the affected node.  The fast (_f) verions sacrifice some safty checks for better performance.  See basic concepts for details. \n\nSee also degree, outdegree \n\nExamples\n\njulia> using Fastnet\n\njulia> net=FastNet(1000,2000,2,[])\nNetwork of 0 nodes and 0 links\n\njulia> n1=makenode!(net,1);\n\njulia> n2=makenode!(net,1);\n\njulia> n3=makenode!(net,1);\n\njulia> makelink!(net,n1,n2);\n\njulia> makelink!(net,n3,n2);\n\njulia> indegree(net,n1)\n0\n\njulia> indegree(net,n2)\n2\n\n\n\n\n\n","category":"function"},{"location":"reference.html#Fastnet.makenode!","page":"Function Reference","title":"Fastnet.makenode!","text":"makenode!(net,s)\nmakenode_f!(net,s)\n\nCreate a new node in state s in the network net and return it's id. \n\nWorst-case performance of both versions of this function scales only with the number of node states.  \n\nThe fast (_f) verions sacrifice some safty checks for better performance.  See basic concepts for details. \n\nSee also destroynode!, makenodes!\n\nExamples\n\njulia> using Fastnet\n\njulia> net=FastNet(1000,2000,2,[])\nNetwork of 0 nodes and 0 links\n\njulia> makenode!(net,2)\n1\n\njulia> net\nNetwork of 1 nodes and 0 links\n\njulia> nodestate(net,1)\n2\n\n\n\n\n\n","category":"function"},{"location":"reference.html#Fastnet.makenodes!","page":"Function Reference","title":"Fastnet.makenodes!","text":"makenodes!(net,N,s)\nmakenodes_f!(net,N,s)\n\nCreate N nodes in state s in the network *net.  \n\nWorst case performance of this function scales only with the number of node states.  The fast (_f) verions sacrifice some safty checks for better performance.  See basic concepts for details. \n\nSee also makenode!, destroynode! \n\nExamples\n\njulia> using Fastnet\n\njulia> net=FastNet(1000,2000,2,[])\nNetwork of 0 nodes and 0 links\n\njulia> makenodes!(net,100,1);\n\njulia> net\nNetwork of 100 nodes and 0 links\n\n\n\n\n\n","category":"function"},{"location":"reference.html#Fastnet.node","page":"Function Reference","title":"Fastnet.node","text":"node(net,rp)\nnode(net,s,rp)\nnode_f(net,rp)\nnode_f(net,s,rp)\n\nDetermine node id from relative position and node state.\n\nThe node function provides a way to access nodes form a the set of nodes in certain states, or from the set of all nodes in a simple way. The two-argument version returns the id of the  node at poition rp in network net. The three-argument version returns the id of the node at  poition rp within all nodes in state s.\n\nAll version of this function run in constant time, but fast (_f) verions sacrifice some safty  checks for better performance. See basic concepts for details. \n\nExamples\n\njulia> using Fastnet\n\njulia> net=FastNet(1000,2000,2,[])\nNetwork of 0 nodes and 0 links\n\njulia> randomgraph!(net)\nNetwork of 1000 nodes and 2000 links\n\njulia> nodestate!(net,123,2)\n\njulia> nodestate!(net,345,2)\n\njulia> node(net,2,1)\n345\n\njulia> node(net,2,2)\n123\n\njulia> node(net,1)\n1\n\njulia> destroynode!(net,1)\n\njulia> node(net,1)\n998\n\n\n\n\n\n","category":"function"},{"location":"reference.html#Fastnet.nodecounts","page":"Function Reference","title":"Fastnet.nodecounts","text":"nodecounts(net)\nnodecounts_f(net)\n\nReturn an Array containing the number of nodes in the vairous node states. \n\nThe time required for this function scales only with the number of node states (it is independent of the number of nodes). \n\nThe alternative (_f) version of this function is identical to nodecounts and is provided only for convenience. \n\nSee also countnodes\n\nExamples\n\njulia> using Fastnet\n\njulia> net=FastNet(1000,2000,2,[])\nNetwork of 0 nodes and 0 links\n\njulia> randomgraph!(net)\nNetwork of 1000 nodes and 2000 links\n\njulia> for i=1:20\n         n=node(net,1,1)\n         nodestate!(net,n,2)\n       end\n\njulia> nodecounts(net)\n2-element Vector{Int64}:\n 980\n  20\n\n\n\n\n\n","category":"function"},{"location":"reference.html#Fastnet.nodeexists","page":"Function Reference","title":"Fastnet.nodeexists","text":"nodeexists(net,nid)\nnodeexists_f(net,nid)\n\nReturn if a node with id nid exists in net, false otherwise.  \n\nThis function runs in constant time.  The fast (_f) verions sacrifice some safty checks for better performance.  See basic concepts for details. \n\nSee also makenode!, destroynode! \n\nExamples\n\njulia> using Fastnet\n\njulia> net=FastNet(1000,2000,2,[])\nNetwork of 0 nodes and 0 links\n\njulia> n1=makenode!(net,1);\n\njulia> nodeexists(net,n1)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"reference.html#Fastnet.nodestate","page":"Function Reference","title":"Fastnet.nodestate","text":"randomnode(net)\nrandomnode(net,s)\nrandomnode_f(net)\nrandomnode_f(net,s)\n\nReturn the id of a random node ddrawn from net.\n\nIf the second argument s is not provided the node will be drawn uniformly from  all nodes in the network. If s is an integer then the node will be drawn uniformly  from the nodes in state s. If s is an Array or Tuple of Ints then the node will be  drawn uniformly from the nodes in the states listed. \n\nThis function runs in constant time if s is integer or omitted. If s is an Array or Tuple the  worst case performance scales only with the number of node states.   The fast (_f) verions sacrifice some safty checks for better performance.  See basic concepts for details. \n\nThe safe versions of this function will throw an ArgumentError with an informative error message when trying to pick a node from an empty set. With the fast (_f) version, trying to pick a node from  an empty set will also result in an ArgumentError being thrown, but in this case the message will be  something like \"Range must be non-empty\".  \n\nSee also node\n\nExamples\n\njulia> using Fastnet\n\njulia> net=FastNet(1000,2000,2,[])\nNetwork of 0 nodes and 0 links\n\njulia> makenodes!(net,100,1);\n\njulia> net\nNetwork of 100 nodes and 0 links\n\n\n\n\n\n","category":"function"},{"location":"reference.html#Fastnet.nodestate!","page":"Function Reference","title":"Fastnet.nodestate!","text":"nodestate!(net,nid,s)\nnodestate_f!(net,nid,s)\n\nSet the node with id nid in net net to s.\n\nWorst-case performance of both versions of this function is O(ks*k)+O(ns) where ks is the number of  tracked link states, k is the degree of the affected node and ns is the number of node states.  \n\nThe fast (_f) verions sacrifice some safty checks for better performance.  See basic concepts for details. \n\nSee also nodestate\n\nExamples\n\njulia> using Fastnet\n\njulia> net=FastNet(1000,2000,2,[])\nNetwork of 0 nodes and 0 links\n\njulia> randomgraph!(net)\nNetwork of 1000 nodes and 2000 links\n\njulia> nodestate(net,1)\n1\n\njulia> nodestate!(net,1,2)\n\njulia> nodestate(net,1)\n2\n\n\n\n\n\n","category":"function"},{"location":"reference.html#Fastnet.outdegree","page":"Function Reference","title":"Fastnet.outdegree","text":"outdegree(net,nid)\noutdegree_f(net,nid)\n\nReturn the outgoing degree of the node with id nid in network net.  \n\nThe worst case performance scales only with the outdegree of the affected node.  The fast (_f) verions sacrifice some safty checks for better performance.  See basic concepts for details. \n\nSee also degree, indegree \n\nExamples\n\njulia> using Fastnet\n\njulia> net=FastNet(1000,2000,2,[])\nNetwork of 0 nodes and 0 links\n\njulia> n1=makenode!(net,1);\n\njulia> n2=makenode!(net,1);\n\njulia> n3=makenode!(net,1);\n\njulia> makelink!(net,n1,n2);\n\njulia> makelink!(net,n3,n2);\n\njulia> outdegree(net,n1)\n1\n\njulia> outdegree(net,n2)\n0\n\n\n\n\n\n","category":"function"},{"location":"reference.html#Fastnet.randomnode","page":"Function Reference","title":"Fastnet.randomnode","text":"randomnode(net)\nrandomnode(net,s)\nrandomnode_f(net)\nrandomnode_f(net,s)\n\nReturn the id of a random node drawn from net.\n\nIf the second argument s is not provided the node will be drawn uniformly from  all nodes in the network. If s is an integer then the node will be drawn uniformly  from the nodes in state s. If s is an Array or Tuple of Ints then the node will be  drawn uniformly from the nodes in the states listed. \n\nThis function runs in constant time if s is integer or omitted. If s is an Array or Tuple the  worst case performance scales only with the number of node states.   The fast (_f) verions sacrifice some safty checks for better performance.  See basic concepts for details. \n\nThe safe versions of this function will throw an ArgumentError with an informative error message when trying to pick a node from an empty set. With the fast (_f) version, trying to pick a node from  an empty set will also result in an ArgumentError being thrown, but in this case the message will be  something like \"Range must be non-empty\".  \n\nSee also node\n\nExamples\n\njulia> using Fastnet\n\njulia> net=FastNet(1000,2000,2,[])\nNetwork of 0 nodes and 0 links\n\njulia> makenodes!(net,100,1);\n\njulia> makenodes!(net,100,2);\n\njulia> nodestate(net,randomnode(net,1))\n1\njulia> nodestate(net,randomnode(net,2))\n2\n\n\n\n\n\n","category":"function"},{"location":"reference.html#Link-Functions","page":"Function Reference","title":"Link Functions","text":"","category":"section"},{"location":"reference.html","page":"Function Reference","title":"Function Reference","text":"countlinks\r\ndestroylink!\r\nmakelink!\r\nnextlinkin\r\nnextlinkout\r\nlink\r\nlinkcounts\r\nlinkdst\r\nlinkexists\r\nlinksrc\r\nlinkstate\r\nrandomlink","category":"page"},{"location":"reference.html#Fastnet.countlinks","page":"Function Reference","title":"Fastnet.countlinks","text":"countlinks(net)\ncountlinks(net,s)\ncountlinks_f(net)\ncountlinks_f(net,s)\n\nCount the links in state s, or, if no state is provided, in the entire network.  \n\nInstead of the state s also an Array or Tuple of states can be passed.  In this case the total number of nodes in all of the listed states is returned. \n\nThe links in a sincle class or the entire network are counted in constant time.  For the tuples or array arguments the performance scales with the number of elements in the  Tulps/Array.  The fast (_f) verions sacrifice some safty checks for better performance.  See basic concepts for details. \n\nIf performance is critical use this function rather than linkcounts.\n\nSee also linkcounts\n\nExamples\n\njulia> using Fastnet\n\njulia> net=FastNet(1000,2000,2,[LinkType(1,2,1),LinkType(2,2,2)])\nNetwork of 0 nodes and 0 links\n\njulia> makenodes!(net,20,1)\n\njulia> makenodes!(net,20,2)\n\njulia> for i=1:20\n         from=node(net,1,i)\n         to=node(net,2,i)\n         makelink!(net,from,to)\n       end\n\njulia> makelink!(net,node(net,2,1),node(net,2,2));\n\njulia> countlinks(net)\n21\n\njulia> countlinks(net,1)\n20\n\njulia> countlinks(net,2)\n1\n\njulia> countlinks(net,[1,2])\n21\n\n\n\n\n\n","category":"function"},{"location":"reference.html#Fastnet.destroylink!","page":"Function Reference","title":"Fastnet.destroylink!","text":"destroylink!(net,kid)\ndestroylink_f!(net,kid)\n\nDestroy the link with id kid in network net. \n\nAll versions of this function run in constant time.  The fast (_f) verions sacrifice some safty checks for better performance.  See basic concepts for details. \n\nSee also makelink!\n\nExamples\n\njulia> using Fastnet\n\njulia> net=FastNet(1000,2000,2,[])\nNetwork of 0 nodes and 0 links\n\njulia> n1=makenode!(net,1);\n\njulia> n2=makenode!(net,2);\n\njulia> makelink!(net,n1,n2);\n\njulia> net\nNetwork of 2 nodes and 1 links\n\njulia> lnk=randomlink(net);\n\njulia> destroylink!(net,lnk)\n\njulia> net\nNetwork of 2 nodes and 0 links\n\n\n\n\n\n","category":"function"},{"location":"reference.html#Fastnet.makelink!","page":"Function Reference","title":"Fastnet.makelink!","text":"makelink!(net,src,dst)\nmakelink_f!(net,src,dst)\n\nCreate a new link from node src to nodedst in the network net and return it's id. \n\nWorst-case performance of both versions of this function scales only with the number of tracked link states.  \n\nThe fast (_f) verions sacrifice some safty checks for better performance.  See basic concepts for details. \n\nSee also destroylink!\n\nExamples\n\njulia> using Fastnet\n\njulia> net=FastNet(1000,2000,2,[])\nNetwork of 0 nodes and 0 links\n\njulia> n1=makenode!(net,1);\n\njulia> n2=makenode!(net,1);\n\njulia> makelink!(net,n1,n2);\n\njulia> net\nNetwork of 2 nodes and 1 links\n\n\n\n\n\n","category":"function"},{"location":"reference.html#Fastnet.nextlinkin","page":"Function Reference","title":"Fastnet.nextlinkin","text":"nextlinkin!(net,kid)\nnextlinkin_f!(net,kid)\n\nGet the id of the next incoming link to the node at the destination of link kid in net. \n\nThis function can be used to iterate over the incoming links of a node. If kid is the nodes last link the return value is zero. \n\nAll versions of this function run in constant time.  The fast (_f) verion sacrifices some safty checks for better performance.  See basic concepts for details. \n\nSee also firstlinkin, nextlinkout\n\nExamples\n\njulia> using Fastnet\n\njulia> net=FastNet(1000,2000,2,[])\nNetwork of 0 nodes and 0 links\n\njulia> n1=makenode!(net,1);\n\njulia> n2=makenode!(net,1);\n\njulia> n3=makenode!(net,1);\n\njulia> n4=makenode!(net,1);\n\njulia> makelink!(net,n2,n1)\n1\n\njulia> makelink!(net,n3,n1)\n2\n\njulia> makelink!(net,n4,n1)\n3\n\njulia> k=firstlinkin(net,n1);\n\njulia> while k!=0\n           println(k)\n           k=nextlinkin(net,k)\n           end\n3\n2\n1\n\n\n\n\n\n","category":"function"},{"location":"reference.html#Fastnet.nextlinkout","page":"Function Reference","title":"Fastnet.nextlinkout","text":"nextlinkout!(net,kid)\nnextlinkout_f!(net,kid)\n\nGet the id of the next outgoing link from the node at the source of link kid in net. \n\nThis function can be used to iterate over the outgoing links of a node. If kid is the nodes last link the return value is zero. \n\nAll versions of this function run in constant time.  The fast (_f) verion sacrifices some safty checks for better performance.  See basic concepts for details. \n\nSee also firstlinkout, nextlinkin\n\nExamples\n\njulia> using Fastnet\n\njulia> net=FastNet(1000,2000,2,[])\nNetwork of 0 nodes and 0 links\n\njulia> n1=makenode!(net,1);\n\njulia> n2=makenode!(net,1);\n\njulia> n3=makenode!(net,1);\n\njulia> n4=makenode!(net,1);\n\njulia> makelink!(net,n1,n2)\n1\n\njulia> makelink!(net,n1,n3)\n2\n\njulia> makelink!(net,n1,n4)\n3\n\njulia> k=firstlinkout(net,n1);\n\njulia> while k!=0\n           println(k)\n           k=nextlinkout(net,k)\n           end\n3\n2\n1\n\n\n\n\n\n","category":"function"},{"location":"reference.html#Fastnet.link","page":"Function Reference","title":"Fastnet.link","text":"link(net,rp) link(net,s,rp) linkf(net,rp) linkf(net,s,rp)\n\nDetermine link id from relative rp  position and node state s.\n\nThe link function provides a way to access links form the set of nodes in a certain link state, or from the set of all links. The two-argument version returns the id of the  link at poition rp in network net. The three-argument version returns the id of the link at  poition rp within the set of links that are in state s.\n\nAll version of this function run in constant time, but fast (_f) verions sacrifice some safty  checks for better performance. See basic concepts for details. \n\nSee also adjacent\n\nExamples\n\njulia> using Fastnet\n\njulia> net=FastNet(1000,2000,2,[LinkType(1,2),LinkType(1,1),LinkType(2,2)])\nNetwork of 0 nodes and 0 links\n\njulia> n1=makenode!(net,1);\n\njulia> n2=makenode!(net,1);\n\njulia> n3=makenode!(net,2);\n\njulia> makelink!(net,n1,n2);\n\njulia> makelink!(net,n2,n3);\n\njulia> makelink!(net,n3,n1);\n\njulia> lid=link(net,2,1);\n\njulia> linkdst(net,lid)==n2\ntrue\n\njulia> linksrc(net,lid)==n1\ntrue\n\n\n\n\n\n","category":"function"},{"location":"reference.html#Fastnet.linkcounts","page":"Function Reference","title":"Fastnet.linkcounts","text":"linkcounts(net)\nlinkcounts_f(net)\n\nReturn an Array containing the number of link in the vairous link states. \n\nThe elements of the array will show the counts in the same order in which the link types  were passed to the FastNet Constructor. \n\nThe time required for this function scales only with the number of link states (it is independent of the number of links). \n\nThe alternative (_f) version of this function is identical only provided for convenience. \n\nSee also countlinks\n\nExamples\n\njulia> using Fastnet\n\njulia> net=FastNet(1000,2000,2,[LinkType(1,2),LinkType(1,1),LinkType(2,2)])\nNetwork of 0 nodes and 0 links\n\njulia> n1=makenode!(net,1);  \n\njulia> n2=makenode!(net,1);\n\njulia> n3=makenode!(net,2);\n\njulia> makelink!(net,n1,n2);\n\njulia> makelink!(net,n2,n3);\n\njulia> makelink!(net,n3,n1);\n\njulia> linkcounts(net)\n3-element Vector{Int64}:\n 2\n 1\n 0\n\n\n\n\n\n","category":"function"},{"location":"reference.html#Fastnet.linkdst","page":"Function Reference","title":"Fastnet.linkdst","text":"linkdst!(net,kid)\nlinkdst_f!(net,kid)\n\nReturn the id of the node at the destination of link kid in net. \n\nAll versions of this function run in constant time.  The fast (_f) verion sacrifices some safty checks for better performance.  See basic concepts for details. \n\nSee also makelink!\n\nExamples\n\njulia> using Fastnet\n\njulia> net=FastNet(1000,2000,2,[])\nNetwork of 0 nodes and 0 links\n\njulia> n1=makenode!(net,1);\n\njulia> n2=makenode!(net,2);\n\njulia> k1=makelink!(net,n1,n2);\n\njulia> linkdst(net,k1)==n2\ntrue\n\n\n\n\n\n","category":"function"},{"location":"reference.html#Fastnet.linkexists","page":"Function Reference","title":"Fastnet.linkexists","text":"linkexists(net,kid)\nlinkexists_f(net,kid)\n\nReturn true node with id kid exists in net, false otherwise.  \n\nThis function runs in constant time.  The fast (_f) verions sacrifice some safty checks for better performance.  See basic concepts for details. \n\nSee also makelink! \n\nExamples\n\njulia> using Fastnet\n\njulia> net=FastNet(1000,2000,2,[])\nNetwork of 0 nodes and 0 links\n\njulia> n1=makenode!(net,1);\n\njulia> n2=makenode!(net,1);\n\njulia> linkexists(net,7)\nfalse\n\njulia> k=makelink!(net,n1,n2);\n\njulia> linkexists(net,k)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"reference.html#Fastnet.linksrc","page":"Function Reference","title":"Fastnet.linksrc","text":"linksrc!(net,kid)\nlinksrc_f!(net,kid)\n\nReturn the id of the node at the source of link kid in net. \n\nAll versions of this function run in constant time.  The fast (_f) verion sacrifices some safty checks for better performance.  See basic concepts for details. \n\nSee also makelink!\n\nExamples\n\njulia> using Fastnet\n\njulia> net=FastNet(1000,2000,2,[])\nNetwork of 0 nodes and 0 links\n\njulia> n1=makenode!(net,1);\n\njulia> n2=makenode!(net,2);\n\njulia> k1=makelink!(net,n1,n2);\n\njulia> linksrc(net,k1)==n1\ntrue\n\n\n\n\n\n","category":"function"},{"location":"reference.html#Fastnet.linkstate","page":"Function Reference","title":"Fastnet.linkstate","text":"linkstate(net,kid)\nlinkstate_f(net,kid)\n\nReturn the state of the link with id kid in network net. \n\nNote that the link states are numbered in the order in which they were passed to  the FastNet Constructor. \n\nAll version of this function run in constant time, but fast (_f) verion sacrifices some safty  checks for better performance. See basic concepts for details. \n\nSee also nodestate!, FastNet\n\nExamples\n\njulia> using Fastnet\n\njulia> net=FastNet(1000,2000,2,[LinkType(1,2),LinkType(1,1),LinkType(2,2)])\nNetwork of 0 nodes and 0 links\n\njulia> n1=makenode!(net,1);\n\njulia> n2=makenode!(net,1);\n\njulia> lnk=makelink!(net,n1,n2);\n\njulia> linkstate(net,lnk)\n2\n\n\n\n\n\n","category":"function"},{"location":"reference.html#Fastnet.randomlink","page":"Function Reference","title":"Fastnet.randomlink","text":"randomlink(net)\nrandomlink(net,s)\nrandomlink_f(net)\nrandomlink_f(net,s)\n\nReturn the id of a random link drawn from net.\n\nIf the second argument s is not provided the link will be drawn uniformly from  all links in the network. If s is an integer then the link will be drawn uniformly  from the links in state s. If s is an Array or Tuple of Ints then the link will be  drawn uniformly from the links in the states listed. \n\nThis function runs in constant time if s is integer or omitted. If s is an Array or Tuple the  worst case performance scales only with the number of tracked link states.   The fast (_f) verions sacrifice some safty checks for better performance.  See basic concepts for details. \n\nThe safe versions of this function will throw an ArgumentError with an informative error message when trying to pick a link from an empty set. With the fast (_f) version, trying to pick a link from  an empty set will also result in an ArgumentError being thrown, but in this case the message will be  something like \"Range must be non-empty\".  \n\nSee also link\n\nExamples\n\njulia> using Fastnet\n\njulia> net=FastNet(1000,2000,2,[LinkType(2,2,2)])\nNetwork of 0 nodes and 0 links\n\njulia> randomgraph!(net);\n\njulia> for i=1:500\n         nd=randomnode(net,1)\n         nodestate!(net,nd,2)\n       end\n\njulia> lnk=randomlink(net,1);\n\njulia> linkstate(net,lnk)\n1\n\n\n\n\n\n","category":"function"},{"location":"reference.html#Simulation","page":"Function Reference","title":"Simulation","text":"","category":"section"},{"location":"reference.html","page":"Function Reference","title":"Function Reference","text":"simstep!\r\nrunsim!","category":"page"},{"location":"reference.html#Fastnet.simstep!","page":"Function Reference","title":"Fastnet.simstep!","text":"simstep!(sim)\n\nSimulate the next event in sim.\n\nThis function will always advance the sim by exactly one event.  Output is generated at start time and directly after the event has occured. \n\nSee also FastSim,simstep \n\nExamples\n\njulia> using Fastnet\n\njulia> net=FastNet(2,1,2,[])\nNetwork of 0 nodes and 0 links\n\njulia> n1=makenode!(net,1);\n\njulia> n2=makenode!(net,2);\n\njulia> function rates!(r,t)\n         r[1]=countnodes(net,2)\n         end\nrates! (generic function with 1 method)\n\njulia> function simpleproc!()\n         node=randomnode(net,2)\n         nodestate!(net,node,1)\n         end\nsimpleproc! (generic function with 1 method)\n\njulia> sim=FastSim(net,rates!,[simpleproc!]; output=false)\nSimulation run, currently at time 0.0\n\njulia> simstep!(sim)\n\njulia> nodecounts(net)\n2-element Vector{Int64}:\n 2\n 0\n\n\n\n\n\n","category":"function"},{"location":"reference.html#Fastnet.runsim!","page":"Function Reference","title":"Fastnet.runsim!","text":"runsim!(sim,dur,out=1.0)\n\nRun the simulation sim for time dur, producing out at intervals out.\n\nDuring the simulation the FastSim and its associated FastNet object will  be updated to reflect the current state of the network (though see notes  on the simulation time, here).  \n\nThis function simulates the FastSim at least for a certain time. If there  are still events occuring in the simulation by the end of the simulation run  the simulation will stop directly after the first event that happens after dur. So the simulation time will always be greater than dur. In general the difference and  the actual simulation time will be tiny, but in case events are extreley rare the simulation may run significantly beyond dur. This behaviour is necessary to  avoid a watchdog-paradox artifact when repeatedly starting short runs. \n\nOutput is generated once at the start of the simulation and then at every multiple of out.  For example, if the simulation time is t=3.12 at the start of the run, dur=10 and out=5 then outputs will be generated at times 3.12, 5 and 10. As a result the network will   be left in a state that differs from the statistics in the last output. \n\nSee also FastSim,simstep! \n\nExamples\n\njulia> using Fastnet\n\njulia> net=FastNet(2,1,2,[])\nNetwork of 0 nodes and 0 links\n\njulia> n1=makenode!(net,1);\n\njulia> n2=makenode!(net,2);\n\njulia> function rates!(r,t)\n         r[1]=countnodes(net,2)\n         end\nrates! (generic function with 1 method)\n\njulia> function simpleproc!()\n         node=randomnode(net,2)\n         nodestate!(net,node,1)\n         end\nsimpleproc! (generic function with 1 method)\n\njulia> sim=FastSim(net,rates!,[simpleproc!]; output=false)\nSimulation run, currently at time 0.0\n\njulia> runsim!(sim,100)\n\njulia> nodecounts(net)\n2-element Vector{Int64}:\n 2\n 0\n\n\n\n\n\n","category":"function"},{"location":"reference.html#Debug-and-Analysis","page":"Function Reference","title":"Debug & Analysis","text":"","category":"section"},{"location":"reference.html","page":"Function Reference","title":"Function Reference","text":"healthcheck\r\nlistnodes\r\nlistneighbors\r\nresults\r\nshowlinks\r\nshownodes","category":"page"},{"location":"reference.html#Fastnet.healthcheck","page":"Function Reference","title":"Fastnet.healthcheck","text":"healthcheck(net)\n\nPerform an internal consistencey check on a FastNet net.\n\nTo achieve the desired performance Fastnet engages in a certain amount of double bookeeping. In an ideal world the FastNet structures should always stay internally consistent. However, inconsistencies could arise from a number of sources including software bugs, CPU and memeory  errors. This function checks the internal data stored in FastNet for consistency to make sure  that everything is alright. \n\nSee also link\n\nExamples\n\njulia> using Fastnet\n\njulia> net=FastNet(100,200,10,[])\nNetwork of 0 nodes and 0 links\n\njulia> healthcheck(net)\n  Checking repository consistency ... OK\n  Checking node accounting ... OK\n  Checking link accounting ... OK\n  Checking endpoint consistency ... OK\n  Checking node stateification ... OK\n  Checking link stateification ... OK\n\n\n\n\n\n","category":"function"},{"location":"reference.html#Fastnet.listnodes","page":"Function Reference","title":"Fastnet.listnodes","text":"listnodes(FastNet)    \nlistnodes(FastNet,state)\n\nReturn a vector of the IDs of all nodes in FastNet net or all nodes in state state in net.\n\nThe one-argument method of this function returns a Vector containing the IDs of all nodes that  are in the network. The two-argument method creates a vector of all nodes in state state.  \n\nSee also listneighbors \n\nExample\n\njulia> using Fastnet\n\njulia> net=FastNet(10,10,2,[])\nNetwork of 0 nodes and 0 links\n\njulia> makenodes!(net,3,1)\n\njulia> makenodes!(net,2,2)\n\njulia> listnodes(net)\n5-element Vector{Int64}:\n 1\n 2\n 3\n 4\n 5\n\n julia> listnodes(net,2)\n 2-element Vector{Int64}:\n 4\n 5 \n\n\n\n\n\n","category":"function"},{"location":"reference.html#Fastnet.listneighbors","page":"Function Reference","title":"Fastnet.listneighbors","text":"listneighbors(FastNet,nid)\n\nReturn a vector of the IDs of all nodes that are asjacent to node nid in FastNet net. \n\nThis function is comparatively slow as it needs to allocate the vector. In your rates!  and process functions it is preferable to iterate over the neighbors using firstlinkout, firstlinkin, nexlinkout, nextlinkin. \n\nSee also listnodes \n\nExample\n\n\njulia> net=FastNet(10,10,2,[])\nNetwork of 0 nodes and 0 links\n\njulia> makenodes!(net,3,1)\n\njulia> makenodes!(net,2,2)\n\njulia> listnodes(net)\n5-element Vector{Int64}:\n 1\n 2\n 3\n 4\n 5\n\n julia> listnodes(net,2)\n 2-element Vector{Int64}:\n 4\n 5 \n\n\n\n\n\n","category":"function"},{"location":"reference.html#Fastnet.results","page":"Function Reference","title":"Fastnet.results","text":"results(FastNet)        \n\nReturn a refernce to the results of sim as a DataFrame\n\nExample\n\njulia> using Fastnet\n\njulia> net=FastNet(1000,2000,2,[]);\n\njulia> makenodes!(net,12,1)\n\njulia> makenodes!(net,34,2)\n\njulia> sim=FastSim(net,(r,t)->nothing,[])\nSimulation run, currently at time 0.0\n\njulia> runsim!(sim,100,25)\nTime     Node state 1    Node state 2\n  0.0              12              34\n 25.0              12              34\n 50.0              12              34\n 75.0              12              34\n100.0              12              34\n\njulia> results(sim)\n5×3 DataFrame\n Row │ Time     Node state 1  Node state 2 \n     │ Float64  Int64         Int64        \n─────┼─────────────────────────────────────\n   1 │     0.0            12            34\n   2 │    25.0            12            34\n   3 │    50.0            12            34\n   4 │    75.0            12            34\n   5 │   100.0            12            34 \n\n\n\n\n\n","category":"function"},{"location":"reference.html#Fastnet.showlinks","page":"Function Reference","title":"Fastnet.showlinks","text":"showlinks(net)\n\nPrint information on all links in FastNet net.\n\nThis function is mainly intended for testing/debugging. Use it only for networks with few links.\n\nSee also shownodes\n\nExamples\n\n```jldoctest julia> using Fastnet\n\njulia> net=FastNet(1000,2000,2,[LinkType(1,1),LinkType(1,2),LinkType(2,2)]);\n\njulia> makenodes!(net,5,1)\n\njulia> makenodes!(net,5,2)\n\njulia> makelink!(net,node(net,1,1),node(net,1,2)); 1\n\njulia> makelink!(net,node(net,1,1),node(net,2,1)) 2\n\njulia> makelink!(net,node(net,2,1),node(net,2,2)) 3\n\njulia> makelink!(net,node(net,2,2),node(net,1,2)) 4\n\njulia> showlinks(net) id      src     dest    state 1       1       2       1 2       1       6       2 3       6       7       3 4       7       2       2 \n\n\n\n\n\n","category":"function"},{"location":"reference.html#Fastnet.shownodes","page":"Function Reference","title":"Fastnet.shownodes","text":"shownodes(net)\n\nPrint information on all nodes in FastNet net.\n\nThis function is mainly intended for testing/debugging. You might want to think twice before  calling it for a large network. Having 10 million nodes printed to your REPL is much less fun than  it sounds. \n\nSee also showlinks\n\nExamples\n\n```jldoctest julia> using Fastnet\n\njulia> net=FastNet(1000,2000,2,[]);\n\njulia> makenodes!(net,5,1)\n\njulia> makenodes!(net,5,2)\n\njulia> shownodes(net) id      state 1       1 2       1 3       1 4       1 5       1 6       2 7       2 8       2 9       2 10      2\n\n\n\n\n\n","category":"function"},{"location":"index.html#Fastnet.jl","page":"Welcome","title":"Fastnet.jl","text":"","category":"section"},{"location":"index.html","page":"Welcome","title":"Welcome","text":"Fastnet is a Julia package tht allows very fast (linear-time) simulation of discrete-state dynamical processes on networks, such as commonly studied models of epidemics","category":"page"},{"location":"index.html","page":"Welcome","title":"Welcome","text":"Fastnet achieves linear-time performance by using an innovative data structure. The underlying netork is a potentially directed and potentially non-simple graph. The package provides a convenient syntax that allows to implement common model in a few simple lines of code. The simulations are done using using an event-driven (Gillespie) algortithm offering fast performance and excellent agreement with real world contious-time processes. Using fastnet models with millions of nodes can be run within minutes on a standard labtop. ","category":"page"},{"location":"index.html#Publication","page":"Welcome","title":"Publication","text":"","category":"section"},{"location":"index.html","page":"Welcome","title":"Welcome","text":"This Package is described also in the following publication","category":"page"},{"location":"index.html","page":"Welcome","title":"Welcome","text":"TBA","category":"page"},{"location":"index.html#Installation","page":"Welcome","title":"Installation","text":"","category":"section"},{"location":"index.html","page":"Welcome","title":"Welcome","text":"Install with the Julia package manager. From the Julia REPL, type ] to enter the Pkg REPL mode and","category":"page"},{"location":"index.html","page":"Welcome","title":"Welcome","text":"pkg> add Fastnet","category":"page"},{"location":"index.html","page":"Welcome","title":"Welcome","text":"Alternatively from Julia","category":"page"},{"location":"index.html","page":"Welcome","title":"Welcome","text":"julia> import Pkg\r\n\r\njulia> Pkg.add(\"Fastnet\")","category":"page"},{"location":"index.html#Getting-started","page":"Welcome","title":"Getting started","text":"","category":"section"},{"location":"index.html","page":"Welcome","title":"Welcome","text":"Check out this tutorial. \nFurther examples can be found in the examples folder on the github repository.\nTo dive deeper it will be helpful to understand the key concepts of Fastnet. ","category":"page"},{"location":"index.html#Acknowledgements","page":"Welcome","title":"Acknowledgements","text":"","category":"section"},{"location":"index.html","page":"Welcome","title":"Welcome","text":"The development of Fastnet was supported by the Volkswagen foundation. The current implementation in Julia was developed at HIFMB, a collaboration between the Alfred-Wegener-Institute, Helmholtz-Center for Polar and Marine Research, and the Carl-von-Ossietzky University Oldenburg, initially funded by the Ministry for Science and Culture of Lower Saxony (MWK) and the Volkswagen Foundation through the “Niedersächsisches Vorab” grant program (grant number ZN3285).","category":"page"},{"location":"faq.html#Frequently-Asked-Questiosn","page":"FAQs","title":"Frequently Asked Questiosn","text":"","category":"section"},{"location":"faq.html#How-large-can-I-make-the-network?","page":"FAQs","title":"How large can I make the network?","text":"","category":"section"},{"location":"faq.html","page":"FAQs","title":"FAQs","text":"This depends mainly on how much memeory you have. Fastnet can simulate networks with several million nodes with relative ease. At some point you will see performance drop on the numeber of hard disk accesses on your operating system will spike. That is the point where Julia runs out of memeory and some of the data needs to get parked on the harddisk. By contrast if you have a lot of memory available Fastnet can coceivably simulate sparce networks with billions of nodes. ","category":"page"},{"location":"faq.html#Can-I-use-muy-own-seed-/-random-number-generator?","page":"FAQs","title":"Can I use muy own seed / random number generator?","text":"","category":"section"},{"location":"faq.html","page":"FAQs","title":"FAQs","text":"Yes, you can initialize your random number generator however you want and then pass it as an argument in the FastNet constructor. ","category":"page"},{"location":"faq.html#Should-I-use-the-fast-functions-or-not?","page":"FAQs","title":"Should I use the fast functions or not?","text":"","category":"section"},{"location":"faq.html","page":"FAQs","title":"FAQs","text":"Use the slow/safe version of Fastnet functions at first. Once everythign runs well switch the function calls in your rates! and process functions to the fast versions. ","category":"page"},{"location":"faq.html#Is-this-the-fastest-network-simulation-code?","page":"FAQs","title":"Is this the fastest network simulation code?","text":"","category":"section"},{"location":"faq.html","page":"FAQs","title":"FAQs","text":"For adaptive networks it probably is, for other models maybe. It may actually depend on a number of details such as the degree distribution of the network","category":"page"},{"location":"faq.html#Can-this-also-do-higher-order-netwworks?","page":"FAQs","title":"Can this also do higher order netwworks?","text":"","category":"section"},{"location":"faq.html","page":"FAQs","title":"FAQs","text":"Fundamentally, no. Many of the tricks we use to speed up things would run into natural boundaries. ","category":"page"},{"location":"faq.html#Can-I-mix-directed-and-undirected-links?","page":"FAQs","title":"Can I mix directed and undirected links?","text":"","category":"section"},{"location":"faq.html","page":"FAQs","title":"FAQs","text":"Yes you can. ","category":"page"},{"location":"faq.html#How-about-temporal-networks?","page":"FAQs","title":"How about temporal networks?","text":"","category":"section"},{"location":"faq.html","page":"FAQs","title":"FAQs","text":"Maybe. This isn't what Fastnet was meant for, but you could try to use the FastNet structure without FastSim and instead write your own simulation code, while taking advantage of the fast bookkeeping FastNet provides. ","category":"page"},{"location":"faq.html#I-have-no-clue-about-Julia.-How-do-I-get-started","page":"FAQs","title":"I have no clue about Julia. How do I get started","text":"","category":"section"},{"location":"faq.html","page":"FAQs","title":"FAQs","text":"Check out the tutorial, particularly the notes on running the example, which are in the final section of the tutorial.","category":"page"},{"location":"faq.html#This-crashed-Julia.-WHo-do-I-blame?","page":"FAQs","title":"This crashed Julia. WHo do I blame?","text":"","category":"section"},{"location":"faq.html","page":"FAQs","title":"FAQs","text":"Yourself. Switch the fast functions for the slow version, rerun and watch for error messages. Likely your model has a logic error or passes wrong arguments to a function. ","category":"page"},{"location":"faq.html#What-do-I-do-if-I-find-a-bug?","page":"FAQs","title":"What do I do if I find a bug?","text":"","category":"section"},{"location":"faq.html","page":"FAQs","title":"FAQs","text":"Send an email to thilo2gross@gmail.com ","category":"page"},{"location":"faq.html#Can-I-also-contact-you-if-I-can't-get-my-model-to-work","page":"FAQs","title":"Can I also contact you if I can't get my model to work","text":"","category":"section"},{"location":"faq.html","page":"FAQs","title":"FAQs","text":"Yes I am happy to help with Fastnet problems, provided you (a) installed Fastnet, (b) read the Tutorial carefully and (c) tried to solve the problem yourself.  ","category":"page"},{"location":"example.html#Example-Library","page":"Example Library","title":"Example Library","text":"","category":"section"},{"location":"example.html","page":"Example Library","title":"Example Library","text":"Below is a list of some Fastnet implementations of common models","category":"page"},{"location":"example.html#Epidemics","page":"Example Library","title":"Epidemics","text":"","category":"section"},{"location":"example.html","page":"Example Library","title":"Example Library","text":"SIS\nSIRS ","category":"page"},{"location":"example.html#Opinion-Dynamics","page":"Example Library","title":"Opinion Dynamics","text":"","category":"section"},{"location":"example.html","page":"Example Library","title":"Example Library","text":"Link-update voter","category":"page"}]
}
